/*
 Copyright: 
 2010 daid KAHL, HASHIMOTO takashi, YAMAGUCHI hidetoshi 
 2011, 2012, 2013, 2015, 2016 daid KAHL

 This file is modified from crabat

 crabat is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 crabat is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with crabat.  If not, see <http://www.gnu.org/licenses/>.
  
*/

/**
@file run.cxx
@author daid
@version 1.0
@brief Code to run the analysis.
@details Reads one or more input ROOT Trees generated by ridf2root.C \n
Calls Analyzer.cxx on the data, and writes out histograms.\n
Allows user input or automation to select run files.\n
Reads input/output directories from run.conf\n
Runtime options dictate how data will be analyzed (raw and/or detailed) and which type of data will be analyzed
(ssd, ppac).\n
@date 07 Nov 2011 18:57:28 
*/

// If run from ROOT, exit with message
#if defined (__CINT__)
{
cout << "This is C++ code, not a ROOT macro!" << endl;
cout << "To continue, run:" << endl;
cout << "make" << endl;
cout << "./run" << endl;
gApplication->Terminate();
}
#endif
using namespace std;
//#include <fstream>
//#include <iostream>
//#include <cstdlib>
//##include <cstring>
#include "run.h" // mainly allocates memory for histograms
#include <getopt.h>
//#include "KVNucleus.h"
//#include "KV2Body.h" 		// KaliVeda class  // removed for now since we don't use it -- uncomment Makefile to enable
#include "Analyzer.cxx" // the analysis code
#include "TRint.h" // so we can run a ROOT session after analysis finishes
// how to get the code of this into doxygen...?
#include "TBrowser.h" // so we can open a TBrowser

/**
@brief Fortran energy loss subroutine. 
@details Uses Ziegler's method for energy loss.  A subroutine for enewz.
@param [in] z1 Proton number of ion.
@param [in] m1 Nucleon number of ion.
@param [in] e Energy of ion (MeV/A).
@param [in] matter1 Matter the ion passes through, as defined in SNKE_MATTER.INC &mdash; Case-insensitive.\n
Must be 32 characters followed by the \0 termination character.
@param [in] unit_pressure Define the units of pressure: 0=solid target ; 1=Torr ; 2=mbar ; 3=atm.
@param [in] pressure Define the value of the pressure (0 for solid target).
@param [in] temperature Define the temperature in Kelvin (0 for solid target).
@param [in] unit_thick Define the units of thickness: 1=mm ; 2=mg/cm<sup>2</sup>
@param [in] thick1 Define the value of the thickness.
@param [out] aft_ene Ion energy after energy loss in matter (MeV/A).
*/
//extern "C" { // removed for now since we don't use it.  Uncomment Makefile to enable
//	void enewzsub_(int *z1, float *m1, float *e, char matter1[33], int *unit_pressure, float *pressure, float *temperature, int *unit_thick, float *thick1, float *aft_ene);
//}

/**
@brief main function of run.cxx which controls everything else.
@details The main function gets the runtime options, can interact with the user to specify run number(s), reads the input ROOT Tree, passes the Tree to Analyzer, Writes the histograms to a new Tree, and optionally launches a ROOT session with a TBrowser attached to the output .root file.\n
Essentially everything is controlled from here.\n
The parameters are just the standard form for getopt parsing.
@see Usage
@param [in] argc getopt argument count
@param [in] arcv getopt argument vector
*/
int main(int argc, char **argv)
{
  int run_no=0,run_no2=-1; // set default run numbers
  // set up the directory structure and file names to be read in
  char file_dir_in[100], file_dir_out[100], header[100];
 
  //getopt parsing
  int c;
  bool flag_type=false;
  bool flag_det=false;
  //opterr = 0; // what was this? 19 Nov 2016 04:14:30 
  while ((c = getopt (argc, argv, "R:H:I:Brdspn")) != -1)
   switch (c)
     {
     case 'R':
       flag_Run = true;
  	sscanf(optarg,"%i",&run_no);
       break;
     case 'B':
       flag_Batch = true;
       break;
     case 'H':
       flag_Header = true;
        sscanf(optarg,"%s",&header[0]);
       break;
     case 'I':
       flag_Inpath = true;
  	sscanf(optarg,"%s",&file_dir_in[0]);
       break;
     case 'r':
       flag_raw = true;
       flag_type=true;
       break;
     case 'd':
       flag_detail = true;
       flag_type=true;
       break;
     case 's':
       flag_ssd = true;
       flag_det=true;
       break;
     case 'p':
       flag_ppac = true;
       flag_det=true;
       break;
     case 'n':
       flag_nai = true;
       flag_det=true;
       break;
     case '?': 
       if (optopt == 'c')
         fprintf (stderr, "Option -%c requires an argument.\n", optopt);
       else if (isprint (optopt))
         fprintf (stderr, "Unknown option `-%c'.\n", optopt);
       else
         fprintf (stderr,
                  "Unknown option character `\\x%x'.\n",
                  optopt);
       Usage();
       return 1;
     default:
       Usage();
       return 1;
     }
   if (!flag_type || !flag_det){ // we need some kind of data to analyze!
     Usage();
     return 1;
   }
   if (flag_Batch && !flag_Run){ // we need a run number for batch mode
     Usage();
     return 1;
   }
  
  ifstream runheaders;
  //We get the file structure from run.conf
  runheaders.open("run.conf");
  string runentry, str_comment = "#";
  int lines=0;
  while (!runheaders.eof()){
    getline(runheaders,runentry);
    if (runentry[0] != str_comment[0] && runentry.length()!=0){
      lines++;
      if (lines > 3) break; // these are run flags for crabat
      if (lines==1 && !flag_Inpath) sprintf(file_dir_in,"%s",runentry.c_str()); // ROOT Input Tree location
      if (lines==2) sprintf(file_dir_out,"%s",runentry.c_str()); // ROOT Output Tree location
      if (lines==3 && !flag_Header) sprintf(header,"%s",runentry.c_str()); // Run header
    }   
  }
  runheaders.close();
  // TODO: Unfuck this logic, holy god
  if ((strcmp("calib",header)==0)||(strcmp("all",header)==0)){
    if (run_no>54 && run_no<100) {
      if (!(strcmp("all",header)==0)){
      cout << "***************************************************" << endl;
      printf("\nRun number %d is not a(n) %s run ... skipping\n\n",run_no,header); 
      cout << "***************************************************" << endl;
      return 0;
      }
    }
    else {
      sprintf(header,"%s","calib");
    }
  }
  if ((strcmp("f2_pid",header)==0)||(strcmp("all",header)==0)){
    if (0) {
      if (!(strcmp("all",header)==0)){
      cout << "***************************************************" << endl;
      printf("\nRun number %d is not a(n) %s run ... skipping\n\n",run_no,header); 
      cout << "***************************************************" << endl;
      return 0;
      }
    }
    else {
      sprintf(header,"%s","f2_pid");
    }
  }
  // checked 10 May 2017 16:18:30 
  if ((strcmp("f3_decay",header)==0)||(strcmp("all",header)==0)) {
    if ( (run_no<46) || (run_no>46 && run_no<52) ||  (run_no>59 && run_no<66) || (run_no>66 && run_no<81) || (run_no>82 && run_no<102) || (run_no>102 && run_no<107) || (run_no>107 && run_no<125) || (run_no>130 && run_no<136) ||  (run_no>138 && run_no<142) || (run_no>145 && run_no<160) || (run_no>163 && run_no<179) || (run_no>181 && run_no<187) || (run_no>189 && run_no<205) || (run_no>205 && run_no<225) || (run_no>227 )) {
      if (!(strcmp("all",header)==0)){
      cout << "***************************************************" << endl;
      printf("\nRun number %d is not a(n) %s run ... skipping\n\n",run_no,header); 
      cout << "***************************************************" << endl;
      return 0;
      }
    }
    else {
      sprintf(header,"%s","f3_decay");
    }
  }
  // checked 10 May 2017 16:14:01 
  if ((strcmp("f3_scattering",header)==0)||(strcmp("all",header)==0)){
    if ( (run_no<47) || (run_no>51 && run_no<60) || (run_no>62 && run_no<68) || (run_no>70 && run_no<83) || (run_no>99 && run_no<103) || (run_no==107) || (run_no>124 && run_no<139) || (run_no>141 && run_no<146) || (run_no>146 && run_no<149) || (run_no>159 && run_no<165) || (run_no==176) || (run_no>178 && run_no<191) || (run_no>203 && run_no<206) || (run_no>206 && run_no<224) || (run_no>224 && run_no<228) || (run_no>229 && run_no<233) ||(run_no>234)) {
      if (!(strcmp("all",header)==0)){
        cout << "***************************************************" << endl;
        printf("\nRun number %d is not a(n) %s run ... skipping\n\n",run_no,header); 
        cout << "***************************************************" << endl;
        return 0;
      }
    }
    else {
      sprintf(header,"%s","f3_scattering");
    }
  }

  // set up the directory structure for file output
  char cmd[200];
  sprintf(cmd,"ls %s/%s/ > /dev/null",file_dir_out,header);
  cout << ".root files in targeted output directory: " << endl;
  if (system(cmd)) { // runs the system command.  if ls is successful, exit status 0, but if it failed exit status 1
        cout << "Creating output directory based on output directory: " << file_dir_out << " and header: " << header << endl; 
	sprintf(cmd,"mkdir -p %s/%s",file_dir_out,header); // if ls failed we need to create the directory for output 
    if (system(cmd)){ cout << "ERROR: No write permission in local directory!" << endl; return 1;} // if mkdir is not successful, report the error and quit
  }
  sprintf(cmd,"ls %s/%s/*.root 2> /dev/null",file_dir_out,header);
  if(system(cmd)){} // if statement only exists to avoid warn_unused_result
  //user friendly run selection
  if (run_no==0) { // run_no is init to 0, unless run is called with a run number explicity (batch mode)
    cout << "Existing runs are: " << endl;
    sprintf(cmd,"ls %s/*.root",file_dir_in);
    if (system(cmd)) {fprintf(stderr,"ERROR: input directory '%s' does not exist!\n",file_dir_in); return(1);} // if we can't find the location to read from, exit with fail status
    
    cout << endl << "Select a run to be analyzed \n";
    cout << "(ie: 1 means "<< file_dir_in <<   "/" << "run1_raw.root \n";
    cout << "1-10 means processing runs 1 through 10): ";
  
    char runnums[200];
    cin >> runnums;
    sscanf(runnums,"%d-%d",&run_no,&run_no2);
  }
  Int_t run_proc = 0;
  if (run_no2==-1) { // only processing one run
    run_no2=run_no;
    cerr << "Processing run " << run_no <<  " only" << endl;
    run_proc = run_no;
  }
  else{
    cerr << "Processing run " << run_no <<  " through run " << run_no2 << endl;
  }
  char file_run[150];
  
  // report what data will be analyzed
  cout << "raw data: " << flag_raw << endl << "detailed data: " << flag_detail << endl <<
  "ssd: " << flag_ssd << endl << "ppac: " << flag_ppac << endl << "nai: " << flag_nai << endl;
  
  //unused for now
  //Int_t nfiles; // count the number of files loaded
  TChain *ch=new TChain("riken_exp"); // create a TChain in the case there is more than one root file to process
  
  for (int rn=run_no;rn<=run_no2;rn++) {
    //make the right file name out of the run
    
    //get a cout on the rn with the printf %4.4d
    sprintf(file_run,"%s/run%d_raw.root",file_dir_in,rn);
    //do the analysis part
    cout << "loading file:" << file_run << endl;
   
    //Checking if the file exists.
    ifstream ifile(file_run);
    if (!ifile.is_open()) {
       cerr << file_run << " could not be opened." << endl;
       return(1); // exit with fail status
    }
    ifile.close();
    
    //nfiles=ch->Add(file_run); 
    ch->Add(file_run);
  } // end for: run_no
  
  // Initalize the histograms
  HistInit();
  // ANALYZE THE DATA!
  Analyzer t(ch); 
  t.Loop(run_proc,flag_raw,flag_detail,flag_ssd,flag_ppac,flag_nai);
  //t.Show(0);
  
  // set up the histogram output file
  char spectra_name[150];
  if (run_no==run_no2) {sprintf(spectra_name,"%s/%s/%d.root",file_dir_out,header,run_no);}
  else {sprintf(spectra_name,"%s/%s/%d_%d.root",file_dir_out,header,run_no,run_no2);}
  TFile *hist_file = new TFile(spectra_name,"RECREATE");
  
  HistWrite(); // Write the histograms
  hist_file->Write(); // write histograms to file
  hist_file->Close(); // close histogram file

  delete hist_file; // delete memory used for histogram file

  new TFile(spectra_name); // open the root file we made because I'm too lazy to find it myself 
  
  // Create interactive interface
  if (!flag_Batch) { //interactive mode is on
    TRint *theApp = new TRint("ROOT example", &argc, argv, NULL, 0);
    // Call an object browser
    new TBrowser();
    // Run interactive interface
    theApp->Run();
  }
  
  // clean up memory allocation
  delete ch; // delete the chain
  // crashes in batch mode...something isn't right in the cleanup, but it's after we've written to disk and closed the histogram file
  // ...hacked solution
  if (!flag_Batch) { //interactive mode is on
    HistClean(); // clean the memory allocated for historgrams (defined in run.h)
  } 
  return(0);	// exit with success status
}
